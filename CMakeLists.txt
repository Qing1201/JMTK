project(kernel)
cmake_minimum_required(VERSION 2.6)

# Build target. Hosted builds a kernel with dummy input/output so it can be run
# as a linux process. X86 is 32-bit, X64 64-bit, and ARM is v7 little endian.
set(TARGET "Hosted" CACHE STRING "Build target type - Hosted, X86, X64 or ARM")

# Ensure all executables are linked against libk, and are wrapped in --whole-archive. We
# need this because there are no hard dependencies between registration functions
# and the HAL.
set(CMAKE_EXE_LINKER_FLAGS
  "${CMAKE_EXE_LINKER_FLAGS} -Wl,--whole-archive ${CMAKE_BINARY_DIR}/src/libk.a -Wl,--no-whole-archive")

# Target specific setup.
if(${TARGET} STREQUAL "Hosted")

  set(CMAKE_EXE_LINKER_FLAGS
    "${CMAKE_EXE_LINKER_FLAGS} -T${CMAKE_SOURCE_DIR}/src/hosted/link.ld")
  list(APPEND DEFINITIONS "-DHOSTED")

endif()
if(${TARGET} STREQUAL "X86")

  # X86 requires the Netwide assembler to build. It can also use Yasm, which
  # is functionally identical.
  find_program(NASM NAMES nasm yasm)
  set(NASM_ARGS -felf)

  # -n stops the Gold linker from creating a new segment to hold the file and program headers for the linux kernel. It unfortunately inserts these
  # in a new segment a page below the .init start address, which is under 1MB and so crashes grub.
  set(CMAKE_EXE_LINKER_FLAGS
    "${CMAKE_EXE_LINKER_FLAGS} -T${CMAKE_SOURCE_DIR}/src/x86/link.ld -nostdlibinc -nostdlib -m32 -Xlinker --build-id=none -lgcc -n")
  list(APPEND DEFINITIONS -DX86 -m32 -ffreestanding)
endif()

# General CFlags for extra warnings and standards compliance, and for not including library
# headers by default.
list(APPEND DEFINITIONS "-Wall" "-Wextra" "-Wno-unused-parameter" "-std=c99" "-nostdlibinc" "-fno-builtin")

# Source include files from src/include and from the build dir,
# for autogenerated headers.
set(INCLUDES ${CMAKE_SOURCE_DIR}/src/include ${CMAKE_BINARY_DIR})
<<<<<<< HEAD
=======
set(SOURCES
  src/adt/ringbuf.c
  src/console.c
  src/hal.c
  src/main.c
  src/string.c
  src/snprintf.c
  src/stdio.c
  src/stdlib.c
  src/readline.c
  src/debugger.c
)
if (${TARGET} STREQUAL "Hosted")
  set(SOURCES ${SOURCES}
    src/hosted/console.c
  )
endif()

if (${TARGET} STREQUAL "X86")
  assemble(SOURCES src/x86/bringup-1.s ${SOURCES})
  set(SOURCES ${SOURCES}
    src/x86/bringup-2.c
    src/x86/screen.c
    src/x86/serial.c
    src/x86/keyboard.c)
endif()
>>>>>>> Add debugger

# Set up the "make check" target for testing.
# Note that qEmu seems not to like having multiple instances of itself running
# at once, so we set the number of threads to 1.
include(FindPythonInterp)
add_custom_target(check "${PYTHON_EXECUTABLE}" "${CMAKE_SOURCE_DIR}/test/lit/lit.py"
  "${CMAKE_SOURCE_DIR}/test" "-sv" "-j1" DEPENDS k)

if (${TARGET} STREQUAL "X86" OR ${TARGET} STREQUAL "X64")
  macro(add_image name target srcs)
    if (${target} STREQUAL "X86")
      add_executable(${name} ${srcs})
      target_link_libraries(${name} k)

      get_target_property(LOC ${name} LOCATION)
      add_custom_target(${name}.img ALL
        "${PYTHON_EXECUTABLE}" "${CMAKE_SOURCE_DIR}/scripts/image.py"
        "${CMAKE_SOURCE_DIR}/src" ${LOC}
        ${LOC}.img DEPENDS ${name})
    endif()
  endmacro(add_image)
endif()

if (${TARGET} STREQUAL "Hosted")
  macro(add_image name target srcs)
    if (${target} STREQUAL "Hosted")
      add_executable(${name} ${srcs})
      target_link_libraries(${name} k)
    endif()
  endmacro(add_image)
endif()

# Create a lit.cfg for running tests.
configure_file("${CMAKE_SOURCE_DIR}/test/lit.site.cfg.in"
  "${CMAKE_BINARY_DIR}/test/lit.site.cfg"  @ONLY)

include_directories(${INCLUDES})
add_definitions(${DEFINITIONS})

add_subdirectory(src)
add_subdirectory(examples)
